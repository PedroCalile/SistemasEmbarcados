Ao excutar este programa, um tubo é criado pelo processo pai, o qual logo após faz
um fork. Quando um processo faz um fork, a tabela de descritores do pai é
automaticamente copiada para o processo filho. No programa, o pai faz um chamada
de sistema pipe() para criar um tubo. Esta rotina cria um tubo e inclui na tabela de
descritores do processos os descritores para os sockets associados às duas
extremidades do tubo. Note que as extremidades do tubo não são equivalentes: o
socket com índice 0 está sendo aberto para leitura, enquanto que o de índice 1 esta
sendo aberto somente para a escrita. Isto corresponde ao fato de que a entrada
padrão na tabela de descritores é associada ao primeiro descritor, enquanto a saída
padrão é associada ao segundo.
Após ser criado, o tubo será compartilhado entre pai e filho após a chamada fork. A
tabela de descritores do processo pai aponta para ambas as extremidades do tubo.
Após o fork,
ambas as tabelas do pai e do filho estarão apontando para o mesmo tubo (herança de
descritores). O filho então usa o tubo para enviar a mensagem para o pai.

1. Quantos pipes serão criados após as linhas de código a seguir? Por quê?
	(a) int pid;
		int	fd[2];
		pipe(fd);
		pid = fork();
	Cria um pipe, para o filho e o pai, pois o fork, compartilha o pipe entre eles.
	(b) int pid;
		int	fd[2];
		pid = fork();
		pipe(fd);
		cria um pipe, pois nao gerou outro processo.

2. Apresente mais cinco sinais importantes do ambiente Unix, além do SIGSEGV, SIGUSR1, SIGUSR2, SIGALRM e SIGINT. Quais são suas características e utilidades?
SIGHUP (1) Corte: sinal emitido aos processos associados a um terminal quando este
se “desconecta”. Este sinal também é emitido a cada processo de um grupo quando o
chefe termina sua execução.

SIGINT (2) Interrupção: sinal emitido aos processos do terminal quando as teclas de
interrupção (por exemplo: INTR, CTRL+c) do teclado são acionadas.
SIGQUIT (3)* Abandono: sinal emitido aos processos do terminal quando com a tecla
de abandono (QUIT ou CTRL+d) do teclado são acionadas.
SIGILL (4)* Instrução ilegal: emitido quando uma instrução ilegal é detectada.
SIGTRAP (5)* Problemas com trace: emitido após cada intrução em caso de geração de
traces dos processos (utilização da primitiva ptrace())
SIGIOT (6)* Problemas de instrução de E/S: emitido em caso de problemas de
hardware.
SIGEMT (7) Problemas de intrução no emulador: emitido em caso de erro material
dependente da implementação.
SIGFPE (8)* Emitido em caso de erro de cálculo em ponto flutuante, assim como no
caso de um número em ponto flutuante em formato ilegal. Indica sempre um erro de
programação.
SIGKILL (9) Destruição: “arma absoluta” para matar os processos. Não pode ser
ignorada, tampouco interceptada (existe ainda o SIGTERM para uma morte mais
“suave” para processos).
SIGBUS (10)* Emitido em caso de erro sobre o barramento.
SIGSEGV (11)* Emitido em caso de violação da segmentação: tentativa de acesso a um
dado fora do domínio de endereçamento do processo.
SIGSYS (12)* Argumento incorreto de uma chamada de sistema.
SIGPIPE (13) Escrita sobre um pipe não aberto em leitura.
SIGALRM (14) Relógio: emitido quando o relógio de um processo pára. O relógio é
colocado em funcionamento utilizando a primitiva alarm().
SIGTERM (15) Terminação por software: emitido quando o processo termina de
maneira normal. Pode ainda ser utilizado quando o sistema quer por fim à execução
de todos os processos ativos.
SIGUSR1 (16) Primeiro sinal disponível ao usuário: utilizado para a comunicação entre
processos.
SIGUSR2 (17) Outro sinal disponível ao usuário: utilizado para comunicação
interprocessual.
SIGCLD (18) Morte de um filho: enviado ao pai pela terminção de um processo filho.
SIGPWR (19) Reativação sobre pane elétrica.
Observação: Os sinais marcados por * geram um arquivo core no disco quando eles
não são corretamente tratados.


3. Considere o código a seguir:

	 1. #include <signal.h>
	 2. #include <unistd.h>
	 3. #include <stdio.h>
	 4. #include <stdlib.h>
	 5.
	 6. void tratamento_alarme(int sig)
	 7. {
	 8. 	system("date");
	 9. 	alarm(1);
	10. }
	11. 
	12. int main()
	13. {
	14. 	signal(SIGALRM, tratamento_alarme);
	15. 	alarm(1);
	16. 	printf("Aperte CTRL+C para acabar:\n");
	17. 	while(1);
	18. 	return 0;
	19. }

Sabendo que a função alarm() tem como entrada a quantidade de segundos para terminar a contagem, quão precisos são os alarmes criados neste código? De onde vem a imprecisão? Este é um método confiável para desenvolver aplicações em tempo real?
